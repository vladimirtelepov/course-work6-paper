\section*{Введение} 
\addcontentsline{toc}{section}{Введение}
Потребность в анализе исполняемого кода возникает у любого специалиста, пытающегося провести анализ достаточно большой программы в отсутствие исходного кода с целью достичь понимания ее устройства. Подобная ситуация возникает при изучении вредоносного кода разработчиками антивирусов, при оценке свойств алгоритмов во время сертификационных испытаний, восстановлении закрытых протоколов для их последующей реализации в программах с открытым исходным кодом, выявлении ошибок и выделении среди них уязвимостей и т.п.

Упомянутая выше задача анализа исполняемого кода является частным случаем более общей задачи исследования семантики кода. Полученный результат может быть использован для решения многих практических задач:
\begin{itemize}
	\item Автоматическая проверка кода -- рекомендация названий имен функций может улучшить читаемость и поддержку кода и упростить использование открытого API, также может использоваться для подсказки правильного названия метода при разработке в IDE;
	\item Автодополнения кода;
	\item Генерация кода;
	\item Распознавание дублирования кода;
	\item Предсказание оптимальных параметров для запуска программы;
	\item Определение класса алгоритма (ускорение reverse-engineering) и др.
\end{itemize}

В последние годы методы машинного обучения стали применяться для большего спектра задач, в частности для задачи анализа исходного и исполняемого кода. Среди прочего, используются методы на основе нейросетей, которые имеют ряд преимуществ. Так, например, нейросеть может тренироваться для решения конкретной задачи, для которой ей могут потребоваться лишь определенные признаки исходного набора данных (это полезно, если набор данных собирается вручную, и генерация некоторых признаков может быть сильно затратной). Следующим достоинством является то, что одна и та же нейросеть может быть обучена на разных наборах данных и может решать несколько разных задач. Вычисление результата предсказания может быть произведено быстро из-за эффективной параллельной реализации на графическом ускорителе. Однако у этих методов есть некоторые недостатки. Одним из условий для применения нейросетей является необходимость наличия большого размеченного набора данных.

Для задач, связанных с исходным кодом, существует множество различных размеченных наборов данных, следовательно указанное ограничение не является проблемой. Однако для задач, связанных с бинарным кодом, проблема стоит достаточно остро. Во-первых, работ по данной тематике не очень много, а наборов данных на популярном ресурсе \footnote{\url{https://paperswithcode.com/}}, содержащем ссылки на статьи с кодом, и вовсе нет. Кроме того, не были найдены наборы данных на сервисе \footnote{\url{https://datasetsearch.research.google.com/}}. Во-вторых, в одних работах авторы используют лишь некоторую статистику, собранную по исполняемым файлам (например, частоты встречаемости байтов или инструкций), а в других - решают задачу на ''модельных'', т.е либо небольших, либо нерепрезентативных, наборах данных. Поиск большого размеченного набора данных из реальных проектов не дал результатов.

В дипломной работе был предложен метод классификации функций в бинарных файлах, который был опробован на декомпилированном наборе данных POJ-104\cite{DBLP:journals/corr/MouLJZW14}. Однако сам набор данных был модельным. Во-первых, в нем были классы, в которых основой частью алгоритма являлась сортировка по ключу, а сами классы отличались лишь структурами. Во-вторых, некоторые классы содержали очень специфичные или мало отличающиеся друг от друга программы. Например, были представлены следующие классы программ: класс программ реализующих удаление подряд идущих пробелов, и класс программ, ищущих все простые числа на заданном отрезке.

В настоящей работе для проверки работоспособности метода на реальных данных было принято решение о самостоятельной сборке набора данных, удовлетворяющего описанным выше требованиям.